/* 파일을 다루기
* 파일 포인터가 필요하다. ==> FILE *fp;
* 파일을 열기 위해서는 ==> fopen_s(&fp, "filename", "rb"); // 파일이 열리지 않을 경우, fp의 값이 NULL이 됨
* 파일에 대한 처리가 끝났으면 ==> fclose(fp);
* FILE이란: 구조체이다. 파일 입출력 함수들이 이 구조체를 사용하여 데이터를 주고 받는다. stdio.h에 정의되어 있다.
*
* 이진파일의 대표적인 예: 영상 파일
* 이진파일 입력: int fread(void *buf, int size, int count, FILE *fp); // 원본은 fp에 있고, *buf에다가 저장해서...어쩔저쩔
* 이진파일 출력: int write(void *buf, int size, int count, FILE *fp); // 원본은 fp에 있고, *buf에다가 출력
* 이진파일 닫음: fclose(fp);
*
* 디지털 영상
* : 픽셀들의 어레이(픽셀들이 행과 열로 배치되어 있음)
* : 흑백 영상의 경우 각 픽셀은 밝기(intensity)값을 가짐. - 각 픽셀의 밝기 값은 0~255 내의 정수
* : 칼라 영상의 경우 각 픽셀은 RGB 3개 채널의 값을 가짐. - R,G,B 각각 채널 값은 0~255 내의 정수
* : 칼라 영상을 흑백 영상으로 변환할 수 있음 --> (R+G+B)/3
* 
* 이진파일의 임의 위치 접근: fseek()
* : int fseek(FILE *fp, long offset, int origin);
* : 인자 origin이 취할 수 있는 값
*   1. SEEK_SET 0 파일의 처음
*   2. SEEK_CUR 1 파일의 현재 위치
*   3. SEEK_END 2 파일의 끝
* : 함수 rewind()
*   1. void rewind(FILE *fp);
*   2. It is equivalent to fseek(fp, 0L, SEEK_SET);
* : 함수 ftell()
*   1. long ftell(FILE *fp);
*   2. It returns the current file position for fp, or -1L on error
* 칼라 영상의 칼라 히스토그램
* RGB 채널의 칼라 영상의 히스토그램을 1D 배열로 구축하고자 한다.
* 1) 칼라의 차원 축소 없이 구현: 채널별 256레벨이므로 경우의 수는 256x256x256 = 16777216이다.
*    따라서 int Chisto[16777216] = {0,}와 같이 1차원 배열을 선언하고 보팅은 r*256^2 + g*256^1 + b*256^0 = bin-number
*    i) 어떤 픽셀의 RGB 값이 주어졌을 때 빈(bin)의 결정
*      i-1) 어떤 픽셀의 값이 RGB(0,0,0)이면 이 값을 보팅할 빈(bin)은 0*256^2 + 0*256^1 + 0*256^0 = 0. 따라서 Chisto[0]++;
*      i-2) 어떤 픽셀의 값이 RGB(255,255,255)이면 이 값을 보팅할 빈(bin)은 255*256^2 + 255*256^1 + 255*256^0 = 16777215. 따라서
*           Chisto[16777215]++;
*    ii) 반대로 어떤 빈 번호가 주어졌을 때 그 빈의 RGB값은?
*        : 256^2: 65536, 256^1: 256, 256^0: 1
*          step1) 주어진 빈 번호를 A라고 하자. A가 65536보다 크거나 같으면 (아니면 R은 0)
                  -> tempR = A/65536.0, R = (int)tempR이고, 여기서  tempR - R > 0.0이면 (0이면 끝이지 모) 
                  A1 = (A-(256^2)*R)라고 하고, A1이 256보다 크거나 같으면 (아니면 G는 0)
                  -> tempG = (A1)/256.0, G = (int)tempG이고, 여기서 tempG - G > 0.0이면
                  B = (A1-(256^1)*G)라 하자. 따라서 RGB(R,G,B)가 된다. 
* 2) 칼라의 채널별 차원을 1/16으로 축소할 경우: 채널별로 칼라가 16레벨이므로 경우의 수는 16x16x16 = 4096.
*    따라서 int Chisto[4096] = {0}와 같이 1차원 배열을 선언하고, 보팅은 (r/16) x 16^2 + (g/16) x 16^1 + (b/16) x 16^0 = bin-number
*    i) 어떤 픽셀의 RGB 값이 주어졌을 때 빈(bin)의 결정
*      i-1) 어떤 픽셀의 값이 RGB(0,0,0)이면 이 값을 보팅할 빈(bin)은 0*16^2 + 0*16^1 + 0*16^0 = 0. 따라서 Chisto[0]++
*      i-2) 어떤 픽셀의 값이 RGB(255,255,255)이면 이 값을 보팅할 빈(bin)은 
            ('255/16'의 정수)*16^2 + ('255/16'의 정수)*16^1 + ('255/16'의 정수)*16^0 = 4095. 따라서 Chisto[4095]++
*      i-3) 어떤 픽셀의 값이 RGB(150,120,84)이면 이 값을 보팅할 빈(bin)은
            ('150/16'의 정수)*16^2 + ('120/16'의 정수)*16^1 + ('84/16'의 정수)*16^0 = 2421. 따라서 Chisto[2421]++
*/
